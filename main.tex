\documentclass[a4paper]{article}
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\usepackage{moreverb}
\usepackage{epsfig}
\usepackage[colorlinks,bookmarksopen,bookmarksnumbered,citecolor=red,urlcolor=red]{hyperref}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{subfigure}
% For table
\usepackage{booktabs}
\usepackage{array}

% Include extern styles
\usepackage{code-styles/nasm/lang}
\usepackage{code-styles/nasm/style}
\usepackage{code-styles/c/style}

\usepackage{color}
\usepackage[lined, linesnumbered, boxed, ruled, commentsnumbered]{algorithm2e}


\begin{document}
\title{Making Fuzz Testing Smart Again}
\author{Bin Zhang}
\maketitle

\begin{abstract}
Coverage based fuzz testing and symbolic execution are both popular program testing techniques in the security research community. However, both of them suffer from scalable problems when considering the size and complexity of modern software. Hybrid testing method mitigates the scalable problem by leveraging symbolic execution to help generate corner test cases for fuzz testing. Although symbolic execution is guaranteed to cover all possible paths theoretically, it still cannot deal well with some specific program structures. Meanwhile, the size of the seed queue of coverage based fuzz testing will become larger with the help of symbolic execution. The seed queue should be rearranged to improve the coverage when given the testing time budget.

In this paper, we introduced two improvements to ease the path explosion problem raised by symbolic execution in hybrid testing method. 
These two improvements focus on symbolic pointers and loops and present a novel lazily symbolic pointer concretization method and a symbolic loop bucket optimization. 
We also proposed a distance based seed selection method to rearrange the seed queue of coverage based fuzz testing to achieve higher coverage in the time budget. We implemented a prototype and the experimental results on several benchmarks demonstrate the efficiency of our method from different viewpoints.
\end{abstract}
\textbf{Keywords.} Fuzz Testing; Symbolic Execution; Software Vulnerability; Hybrid Testing

\section{Introduction} \label{sec:introduction}
\input{Introduction.tex}

\section{Easing Path Explosion in Hybrid Testing} \label{sec:ease PE}
\input{selective-assist.tex}

\section{Distance based Seed Selection} \label{sec:seed selection}
\input{seed-priority.tex}

\section{Implementation and Experimental Evaluation} \label{sec:evaluate}
\input{Implementation.tex}

\input{Evaluation.tex}

\section{Discussion} \label{sec:discussion}
Our method is built on top of fuzz testing and symbolic execution, where we have introduced distance based seed search strategy, symbolic loop bucket, and lazy symbolic pointer. But there are still some drawbacks in our method, so in this section, we will discuss the limitations of our method and take a future look at the vulnerability discovery.

\noindent\textit{\textbf{Distance Measure:}} Our seed prioritization strategy leverages three well-known distance measures, i.e. Euclidean Distance, Cosine Similarity and Jaccard Index. Also, we have evaluated these three measures and compared the results with no search strategy. In the future, we still need to check more definitions of distance, like hamming distance, N-gram distance and so on, to find a better measurement for different execution paths (or different seed inputs). 

\noindent\textit{\textbf{Plain Input Format:}} Our seed prioritization strategy cannot contribute performance gain if the input has no specific format. As shown inn Figure~\ref{path-detail}(a), all of these three distance based prioritization strategies failed to trigger more new behaviors for \texttt{capstone} which accepts the plain texture file as input. 

\noindent\textit{\textbf{Float Point Operation:}} The symbolic execution engine we depend on will concretize symbolic write operations to \texttt{XMM} registers, which will lose some interesting paths when handling float point arithmetic operations. This problem happens for most of the MEPG process programs. So the symbolic execution engine should be upgraded to support float point arithmetic operations well in the future.

\noindent\textit{\textbf{Sanity Check of Symbolic Pointer:}} When given a symbolic pointer, our LSP method will fork a pending state and then continue executing the program until a fork on a branch related to this pending state is failed. Then, we can improve the coverage by scheduling the pending state to generate a new test case. However, a symbolic pointer can point to multiple destinations, our LSP method only focuses on improving the following execution coverage, and because we perform a scale controlled symbolic execution, we will kill this pending state after the execution is terminated and not generate all the possible test cases for this symbolic pointer. This will miss some interesting paths and even bug paths. So, it will be our future work to model the process memory map and then perform assertion checks when encountering with a pending state.

\section{Related Work} \label{sec:related}
We have presented the major advantages of our method in the previous sections and compared our system with some state-of-the-art vulnerability discovery tools. In this section, we present the techniques that related to our method.

\noindent\textit{\textbf{Similarity Distance in Regression Testing:}}
Similarity based algorithms have been leveraged to regression test case prioritization. Test case prioritization issue is a hot research topic in regression testing research, which tries to optimum mutation schedule based on a specific prioritization criterion. Rothermel et, al. proposed fine-grained prioritization strategy based on the instruction coverage and branch coverage. Then Elbaum et, al. concentrated on function level coverage and they proved that this kind of coarse-grained instrumentation which can reduce the execution overhead but will lose some prioritization performance. Krishna et al. utilized Levenshtein distance as the criterion of prioritization. Rather than using an ordered branch sequence to present the path in [XX], we represented the execution path by using the bitmap in AFL, which is more practical and efficiency.

\noindent\textit{\textbf{Combinational Testing Method:}}
As mentioned before, our method is not the first tool to combine fuzz testing and symbolic execution. Hybrid Fuzz Testing uses symbolic execution to discover frontier nodes that represent unique paths in the program. After collecting as many frontier nodes as possible under a user-specifiable resource constraint, it transits to fuzz the program with random inputs. This tool focuses on binaries but only performs the one-time transition between symbolic execution and fuzz testing. Hybrid Concolic Testing implements multiple transitions between symbolic execution and fuzz testing. But because it is built on top of CUTE, a source code oriented testing tool, so hybrid concolic testing still cannot be deployed on binary testing directly. Driller is an up-to-date hybrid testing tool that leverages fuzz testing and concolic execution in a complementary manner to find deeper bugs. It is more practice when compared with previous hybrid tools. Some other tools try to make full use of symbolic execution to maximize the code coverage, they collect symbolic constraints placed on each input and then negating these constraints to generate a new test case that will take another uncovered path, such as SAGE, Dowser, FuzzWin etc. However, as these tools execute each input in the symbolic mode which determines that they have to face the path explosion problem. 

\section{Conclusion} \label{sec:conclusion}
In this paper, we focused on improving the performance of hybrid testing method built on coverage based fuzz testing and symbolic execution. We proposed a novel method namely lazily concretization to deal with symbolic pointers, and this method can postpone the ``path explosion'' problem but also improve the coverage. We also made an optimization based on loop bucket to avoid generating too many states in symbolic loops. To deal with the large size of seed queue in hybrid testing, we present a distance based seed selection method to achieve more coverage when testing time is limited. This criteria of selection method is built on top of runtime information (i.e, path and memory information). We implemented a prototype and the evaluation results on some benchmarks demonstrates our method can discover more paths and bugs when compared with other off-the-shelf vulnerability discovery tools.

\bibliography{biblio.bib}
\bibliographystyle{plain}

\end{document}
