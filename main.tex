% smrdoc.tex V2.10, 13 July 2012

\documentclass[a4paper]{article}
\usepackage{geometry}
\geometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
\usepackage{moreverb}
\usepackage{epsfig}
\usepackage[colorlinks,bookmarksopen,bookmarksnumbered,citecolor=red,urlcolor=red]{hyperref}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
% For table
\usepackage{booktabs}
\usepackage{array}

% Include extern styles
\usepackage{code-styles/nasm/lang}
\usepackage{code-styles/nasm/style}
\usepackage{code-styles/c/style}

\usepackage{color}
\usepackage[lined, linesnumbered, boxed, ruled, commentsnumbered]{algorithm2e}


\begin{document}
\title{Making Fuzz Testing Smarter Again}
\author{Beary, Hu Dou}
\maketitle

\begin{abstract}
% Vulnerbility is very critical. Fuzz testing is a very popular in finding bugs. While this method is quit dumb when compared with symbolic execution.
% In order to improve the ability of fuzz testing itself, we proposed seed prioritization method to select most promising seed to be mutated first. Then fuzz testing cannot test deeper code blocks which we use hybrid testing method to assit it. 
% We implemented the prototype and evaluated it on some real-world binaies to demonstrate its effectiveness and efficiency. The experiments results show our prototype can be smarter than some other vulnerability discovery tools.

% FIXME:
Fuzz testing is a popular method to discover the bugs and vulnerabilities in software. However, traditional fuzz testing still faces the low coverage and fewer efficiency problems when testing real-world binary executables. Treating the program as a black-box makes it harder for fuzz testing to steer the program into deeper state space. In this paper, we improved the ability of fuzz testing itself by prioritizing the seed queue in coverage based evolutionary testing. Meanwhile, we took the advantage of hybrid testing method to improve the coverage with the assistance from symbolic execution. We have proposed two main optimizations to improve the ability of hybrid testing method. We also designed and implemented a prototype tool -- Beary on top of fuzz testing and symbolic execution, and the experiments results on real-world binary software have demonstrated that our method can make the fuzz testing more smarter when compared with other vulnerability discovery tools.
% Need to be refactored

\end{abstract}
\textbf{Keywords.} Fuzz Testing; Symbolic Execution; Vulnerability; Hybrid Testing Method

\section{Introduction}
\input{Introduction.tex}

\section{High Level Overview}
\input{framework.tex}

\section{Seed Prioritization for Fuzz Testing}
\input{seed-priority.tex}

\section{Selective branch query} 
\input{selective-assist.tex}

\section{Implementation}
\input{Implementation.tex}


\section{Evaluation}
\input{Evaluation.tex}

\section{Discussion}
Our method is built on top of fuzz testing and symbolic execution, where we have introduced distance based seed search strategy, symbolic loop bucket, and lazy symbolic pointer. But there are still some drawbacks in our method, so in this section, we will discuss the limitations of our method and take a future look at the vulnerability discovery.

\noindent\textit{\textbf{Distance Measure:}} Our seed search strategy leverages three well-known distance measures, i.e. Euclidean Distance, Cosine Similarity and Jaccard Index. Also, we have evaluated these three measures and compared the results with no search strategy. In the future, we still need to check more definitions of distance, like hamming distance, N-gram distance and so on, to find a better measurement for different execution paths (or different seed inputs). 

\noindent\textit{\textbf{Sanity Check of Symbolic Pointer:}} When given a symbolic pointer, our LSP method will fork a pending state and then continue executing the program until the forking on a branch related to this pending state is failed. Then, we can improve the coverage by scheduling the pending state to generate a new test case. However, a symbolic pointer can point to multiple destinations, our LSP method only focuses on improving the following execution coverage, and because we perform a scale controlled symbolic execution, so we will kill this pending state after the execution is terminated and we will not generate all the possible test cases for this symbolic pointer. This will miss some interesting paths and even bug paths. So, it will be our future work to model the process memory map and then perform assertion checks when encountering with a pending state.

\section{Related Work}
We have presented the major advantages of our method in the previous sections and compared our system with some state-of-the-art vulnerability discovery tools. In this section, we present the techniques that related to our method.

\noindent\textit{\textbf{Similarity Distance in Regression Testing:}}
Similarity based algorithms have been leveraged to regression test case prioritization. Test case prioritization issue is a hot research topic in regression testing research, which tries to optimum mutation schedule based on a specific prioritization criterion. Rothermel et, al. proposed fine-grained prioritization strategy based on the instruction coverage and branch coverage. Then Elbaum et, al. concentrated on function level coverage and they proved that this kind of coarse-grained instrumentation which can reduce the execution overhead but will lose some prioritization performance. Krishna et al. utilized Levenshtein distance as the criterion of prioritization. Rather than using an ordered branch sequence to present the path in [XX], we represented the execution path by using the bitmap in AFL, which is more practical and efficiency.

\noindent\textit{\textbf{Combinational Testing Method:}}
As mentioned before, our method is not the first tool to combine fuzz testing and symbolic execution. Hybrid Fuzz Testing uses symbolic execution to discover frontier nodes that represent unique paths in the program. After collecting as many frontier nodes as possible under a user-specifiable resource constraint, it transits to fuzz the program with random inputs. This tool focuses on binaries but only performs the one-time transition between symbolic execution and fuzz testing. Hybrid Concolic Testing implements multiple transitions between symbolic execution and fuzz testing. But because it is built on top of CUTE, a source code oriented testing tool, so hybrid concolic testing still cannot be deployed on binary testing directly. Driller is an up-to-date hybrid testing tool that leverages fuzz testing and concolic execution in a complementary manner to find deeper bugs. It is more practice when compared with previous hybrid tools. Some other tools try to make full use of symbolic execution to maximize the code coverage, they collect symbolic constraints placed on each input and then negating these constraints to generate a new test case that will take another uncovered path, such as SAGE, Dowser, FuzzWin etc. However, as these tools execute each input in the symbolic mode which determines that they have to face the path explosion problem. 

\section{Conclusion}
In this paper, we proposed a framework built on top of fuzz testing and symbolic execution to improve the performance of path discovery in vulnerability detection for binary executables. In order to achieve this, we introduced three key improvements, i.e. distance based seed search method, symbolic loop bucket and lazy symbolic pointer. The experiments on different benchmarks have shown that by introducing these three key improvements, our framework can find more paths and bugs when compared with other off-the-shelf vulnerability discovery tools. 

\bibliography{biblio.bib}
\bibliographystyle{plain}

\end{document}
