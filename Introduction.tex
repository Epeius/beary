Fuzz testing is a popular technique for automatic software
vulnerability detection \cite{Miller:Fuzz, 5010257, sutton2007fuzzing},
but suffers from low efficiency when applied to real-world software
\cite{neystadt2008automated, godefroid2008automating, ganesh2009taint,
cadar2011symbolic, rawat2017vuzzer, stephens2016driller}. Software
often parses complex input formats such as PDF, DOCX, or JPEG, which
generates deep execution paths with complex conditions. Traditional
random fuzzers generate shallow test cases because they are unable to
guess the inputs that would help reach deeper parts of the code. More
sophisticated fuzzers discard test inputs that do not add new coverage
and keep the remaining inputs in a seed file queue. They then derive
new test input from the seed queue using genetic algorithms
\cite{rawat2017vuzzer, online:afl, stephens2016driller}. Although
coverage-based fuzz testing is able to discover more paths than
traditional fuzz testing, it is nevertheless incapable of triggering
bugs that are deeply nested in complex code areas, due to the random
nature of the mutations.

Dynamic symbolic execution alleviates some of the challenges
encountered by fuzzers. Whereas fuzzers try millions of different
concrete inputs (e.g., "abc", 1, ...) in order to reach deeper parts of
the code, symbolic execution uses symbolic inputs (e.g., $\lambda$)
that concisely summarize all possible concrete values (e.g., all values
of a 32-bit integer). When a symbolic value reaches a branch condition,
the symbolic execution engine invokes a constraint solver in order to
compute the exact value that would drive the program down the desired
path. Unfortunately, pure symbolic execution often results in an
exponential number of paths that bottlenecks the constraint solver.

Recent work aims to combine the advantages of symbolic execution and
fuzz testing. In this hybrid approach~\cite{godefroid2012sage,
yeh2015craxfuzz, majumdar2007hybrid, pak2012hybrid}, corner cases that
are difficult for fuzzers to cover are generated from dynamic symbolic
execution by solving the corresponding path constraints. Conversely,
dynamic symbolic execution also benefits from the fuzzer-generated
seeds in order to quickly reach more code areas without getting lost in
a large execution tree. Driller, which is built on top of the Angr
symbolic execution engine \cite{Shoshitaishvili_firmalice-automatic},
and the AFL fuzzing engine \cite{online:afl}, have attempted to
leverage symbolic execution to solve the branches guarded by complex
path conditions to avoid saturation of fuzzer
\cite{stephens2016driller}. Driller's performance in DARPA's Cyber
Grand Challenge (CGC) \cite{online:CGC} demonstrates the potential of
these hybrid testing approaches.

In hybrid testing, such as Driller, the performance gain from dynamic
symbolic execution is still limited by particular program
structures, such as symbolic pointers and loops~\cite{schwartz2010all,
Boonstoppel:RAP, cadar2011symbolic, baldoni2016survey}. These structures
quickly generate many redundant paths that do not trigger new behaviors
but result in \textit{path explosion}. This is compounded by the possibly
large number of seed files generated by the fuzzer.

This paper makes three main contributions. We propose three new
techniques to improve the efficiency of hybrid testing. First, we
improve the lazy concretization of symbolic pointers presented
in~\cite{chipounov2011s2e}. Second, we enhance the AFL's loop bucketing
technique~\cite{online:afl} in order to avoid getting stuck in loops
that have a symbolic iteration counter. Third, in order to address the
large size if the seed queue, we propose a distance-based seed
selection algorithm in order to improve coverage when testing time is
limited. Each seed in the queue is weighted and prioritized according
to run time information like path and memory coverage.

Our experiments show that the \prototype we built triggers more bugs
than other state-of-the-art vulnerability detection tools. We
benchmarked \prototype on (1) a sample program that contains 9
different types of representative bugs, (2) the LAVA benchmark suite
\cite{dolan2016lava}, and (3) a set of UNIX programs. Our approach can
discover 43\% more unique paths on average than traditional random fuzz
testing.

The rest of this paper is organized as follows.
Section~\ref{sec:preliminaries} introduces dynamic symbolic execution
and hybrid testing. Section~\ref{sec:ease PE} presents the details of
how we deal with \textit{path explosion} caused by symbolic pointers
and loops. Section~\ref{sec:seed selection} presents the distance-based
seed selection algorithm. Section~\ref{sec:evaluate} describes the
implementation of \prototype and the evaluation results.
Section~\ref{sec:discussion} discusses the limitations of our work and
possible improvements. Finally, Section~\ref{sec:related} reviews
related work and Section~\ref{sec:conclusion} concludes the paper.
