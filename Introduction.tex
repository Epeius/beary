Software errors and vulnerabilities have brought critical threaten to not only individuals but also for the whole cyber security. Despite the software quality of software engineering has ever-increasing, some software vulnerabilities still can be found every year by researchers both in academia and industrial communities. 

Even though some software errors and vulnerabilities can be discovered manually, manual analysis is still not a scalable method for large-scale software. During the past several years, many automatic methods have been proposed to improve the dependability of software before and after the software have been released, like source code auditing, fuzz testing, symbolic execution. However, all of these methods still need to solve some obstacles before they can be well applied to large-scale real-world software.

Source code auditing is a powerful methodology for locating security vulnerabilities in source code \cite{Kuperman:Detection, Lee:audit, schmeelk2012standardizing}. However, the need to access source code prevents it from being deployed onto binary software testing to detect vulnerabilities in the released binary executables. The needs to access source code prevent it from being deployed onto binary software testing. And even though it can obtain more information from the source code than binary, it still cannot make sure there are no vulnerabilities in the released binary executables.
Fuzz testing tires to automatically discover vulnerabilities by feeding the target program with a large amount of inputs \cite{Miller:Fuzz}. Fuzz testing can be easily applied both on source code and binary executables which makes it to be the most popular technique in the industrial community. Lots of security bugs have been found by fuzz testing. However, a large portion of released fuzzing tools treats the target software as a black box which simply feeding the target binaries with randomly generated test cases. The complex input formats in modern software determines only a very small portion of the randomly generated test cases can trigger new behaviors of the target binary by touching new paths. So the efficiency is the main bottle-neck of fuzz testing when testing real-world software.

Symbolic execution is an analysis method to automatically generate an input that can drive some specific code region to be executed \cite{King:Symbex}. Symbolic execution interprets the target program by assigning symbolic data rather than concrete data to the program inputs and then uses SAT solvers to generate test cases that satisfy with both branches when encountering a branch. However, the "path explosion" problem impedes symbolic execution from applying to real-world software \cite{Boonstoppel:RAP}. During the recent years, some improvements have been made to help symbolic execution to be adaptable to real-world testing, like, selective symbolic execution and so on. Selective symbolic execution bounds the number of execution states though "elastic" expanding the program execution path \cite{chipounov2009selective, chipounov2011s2e}. Selective symbolic execution has eased the ``path explosion'' problem to some extent and made it possible for applying symbolic execution to real-world software. There are other symbolic execution tools have been developed such as EXE \cite{cadar2006exe}, KLEE \cite{cadar2008klee}, Mayhem \cite{cha2012unleashing}, Manticore \cite{online:manticore},and Angr \cite{shoshitaishvili2016sok}. 

We realized that even the state-of-the-art effective technique base on program analysis is less efficient than black box fuzzing if the time spent generating a test case take relatively too long. Symbolic execution has to spend the most time on program analysis and constraint solving, while black box fuzzing only concentrate on random mutations. 
In this paper, we aim to improve the performance of fuzz testing by adding two main features for fuzz testing. We proposed a distance based seed privatization strategy for fuzz testing to speed up the path discovery by selecting the most promising seed file to mutate, and we also leveraged symbolic execution to improve the coverage of fuzz testing by selectively solving the branches which are guarded by complex conditions. And we also designed and implemented the prototype which is built on top of our method. Furthermore, some additional evaluations on different benchmarks are performed to demonstrate the ability of our methods.
 
In summary, this paper makes the following contributions.
\begin{itemize}
\item A \emph{distance based seed privatization} method is proposed to improve the path discovery.

\item A novel method based on lazy forking is presented to handle the \emph{symbolic pointers} when using symbolic execution to assist fuzz testing.

\item We designed and built the prototype for our method to demonstrate our approaches.

\item We evaluated our method and prototype on several benchmarks to demonstrate the performance from several different viewpoints.
\end{itemize}
