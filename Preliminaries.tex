%Preliminaries of symbolic execution and hybrid testing

In this section, we first review the theoretical foundation of dynamic
symbolic execution. Then we provide a simple example in
Listing~\ref{PRE} to illustrate the concept of hybrid testing based on
fuzz testing and dynamic symbolic execution.

\subsection{Dynamic Symbolic Execution}

Symbolic execution is an analysis method to determine what input can
drive execution to specific code regions \cite{King:Symbex}. It
interprets the program by assigning \textit{symbolic data} rather than
actual (\textit{concrete}) data to the program inputs.

Consider a program $P$ which consists of a set of program variables
$Var$ and a set of instructions $Inst$. 
An \textbf{\textit{execution path}} is a serial of instructions, such as 
$I_0\rightarrow I_1 \rightarrow \cdots\rightarrow I_n$, where $I_i\in Inst$.
Unlike execution path, which focuses on instructions, a 
\textbf{\textit{program state}} holds the value of each variable (a variable 
can be represented by either register or memory).
Since the bits of register and memory are bounded, the number of program
state can be enumerated. However, the total number of execution path 
may be infinite, which is also known as ``path explosion'' problem.

Dynamic symbolic execution
maintains a \textbf{\textit{symbolic state}} 
$\mathcal{S}=\langle I,M,S,pc\rangle$, where 
$I\in Inst$ denotes the next instruction to be executed, 
$M$ is the concrete memory store which maps $Var$ to concrete data, 
$S$ is the symbolic memory store which maps $Var$ to symbolic expressions, 
and $pc$ is the symbolic path constraint which is a first order 
quantifier free formula over symbolic expressions. Since each symbolic state 
can be individually mapped to an execution path, we can use \textit{symbolic state} 
to equivalently represent an execution path.
In the following sections of this paper, all \textit{states} 
denote the \textit{symbolic state} unless explicitly stated. 
And the ``path explosion'' problem can also be expressed as ``state explosion''.

Under dynamic symbolic execution, program $P$ operates on both concrete
memory $M$ and symbolic memory $S$ by executing each instruction $I\in
Inst$. The semantics for different types of instructions are listed in
Table~\ref{table:DSE-inst}.

\begin{table}[!b]
\processtable{Instructions in dynamic symbolic execution, as well as
	 their expressions and semantics.\label{table:DSE-inst}}
{\begin{tabular*}{20pc}{@{\extracolsep{\fill}}lcl@{}}\toprule
Type  & Expression & Semantic\\
\midrule
Assignment   &  $v:=e$ & Update $v$ with expression $e$\\
Terminate    &  abort/exit & Terminate current state \\
Conditional  &  \textbf{if} $e$ \textbf{then} $I_{true}$ \textbf{else} $I_{false}$ & Fork current state\\
\botrule
\end{tabular*}}{}
\end{table}

The objective of dynamic symbolic execution is to systematically
explore all feasible paths of program $P$ under the initial input.
Consider an input vector $\iota$ which steers program $P$ to execute a
unique finite program trace
$s_0\xrightarrow{I_1}s_1\cdots\xrightarrow{I_n}s_n$, where $I_1\cdots
I_n\in Inst$ and $s_1\cdots s_n$ are program states. Then during the
execution of dynamic symbolic execution, different types of
instructions are handled differently according to their semantics. If
$I_i$ is an assignment instruction $v:=e$, dynamic symbolic execution
updates the symbolic memory of $v$ directly with expression $e$, i.e.,
$S(v):= e$. If $I_i$ is a conditional instruction as defined
previously, any satisfying assignments to the Boolean expression
$pc\wedge e$ will lead $P$ to execute the \textit{then} branch and any
satisfying assignments to Boolean expression $pc\wedge\neg e$ will
steer $P$ to run the \textit{else} branch. Dynamic symbolic execution
tries to explore both \textit{then} and \textit{else} branches
simultaneously by \textit{state forking}. To fork a new state, dynamic
symbolic execution uses a constraint solver $T$ to generate
solutions both for $pc\wedge e$ and $pc\wedge\neg e$ and updates the
path constraints accordingly. By forking new program state for each
executed conditional instruction, all possible path constraints can be
enumerated and eventually all feasible paths in $P$ can be exercised.
Whenever dynamic symbolic execution executes a terminate instruction,
it terminates the current state and employs the constraint solver to
solve the current $pc$ to generate a corresponding \textit{test input}.

Dynamic symbolic execution is affected by the \textit{path explosion}
problem. Since dynamic symbolic execution may fork a new state for
every conditional branch, the number of states may grow exponentially
in the number of conditional instructions~\cite{cadar2013symbolic}. A
large number of states will quickly exhaust computation resources halt
testing.

\subsection{Hybrid Testing}

The sample program in Listing~\ref{PRE} tries to verify the three input
parameters. Hybrid testing starts from a coverage-based fuzzer which
quickly generates an input that satisfies the \textit{else} branch
of the conditional instruction at line 2. However, verification of
\texttt{checksum} at line 5 would typically prevent the fuzzer from
going any further. When the fuzzer gets stuck, hybrid testing switches to
dynamic symbolic execution engine to get more coverage.

\lstinputlisting[label={PRE}, language=C,style=c,caption={A motivating
	code for preliminaries. Note that all example code in this paper is
	given as source code for readability, but our approach operates
	directly on binary programs.}]{codes/pre.c}

Figure~\ref{s2e-assist} shows the general architecture of a hybrid testing
approach based on fuzz testing and symbolic execution. The fuzzing engine 
performs coverage-based fuzz testing, and shares the already explored 
path information with the symbolic execution engine. This already explored 
path information can be recorded in any forms. For example, AFL 
intercepts transitions between basic blocks as well as the branch-taken 
hit counts, and store these information into a \textit{Bitmap}.
Then each test case in the seed queue will be sent to symbolic execution 
engine to disclose more new paths.
Unlike traditional dynamic symbolic execution, the symbolic execution engine
only forks for branches that have not been previously covered. For
example, as shown in Figure~\ref{s2e-assist}, suppose the red execution
trace is the path that the fuzzer will taken. In this case the symbolic
execution engine will only fork new states when it finds uncovered
branches (the blue branches) according to the shared internal
information from the fuzzer. Each forked state will generate a new test
case which can help the fuzzer to reach new code areas. Based on this
hybrid testing method, the verification of \texttt{header->checksum} at
line 5 can be solved by symbolic execution engine and generate a new
test case for further fuzzing.

However, function \texttt{path\_explosion} makes it hard to solve the 
conditional instruction at line 9. For example, when using BFS exploration 
strategy, this function will quickly saturate the symbolic state's number 
budget that used to avoid memory overhead \cite{stephens2016driller}; DFS 
exploration works better than BFS in this example, but it may degrade to 
exhaustive testing in some cases (e.g., when \texttt{path\_explosion} deals
\texttt{flag} as a symbolic pointer). 
We will discuss our mitigation
for this problem in Section~\ref{sec:ease PE}.
