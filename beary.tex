\documentclass{cta-author}
\usepackage{listings}
\usepackage{algorithm2e}
\usepackage{code-styles/c/style}
\usepackage[]{amsmath}
\newtheorem{theorem}{Theorem}{}
\newtheorem{corollary}{Corollary}{}
\newtheorem{remark}{Remark}{}
\usepackage[utf8]{inputenc}

\newcommand{\prototype}{\textsc{Breacher} }

\begin{document}

\supertitle{Submission Template for IET Research Journal Papers}

\title{Discover Deeper Bugs with Dynamic Symbolic Execution 
	and Coverage-based Fuzz Testing}

\author{\au{Bin Zhang$^{1,2\corr}$}, 
	\au{Chao Feng$^{1}$}, 
	\au{Adrian Herrera$^2$}, 
	\au{Vitaly Chipounov$^3$}, 
	\au{George Candea$^2$}, 
	\au{Chaojing Tang$^{1}$}}
%
\address{\add{1}{School of Electronic Science and Engineering, 
		National University of Defense Technology (NUDT), 
		Changsha, Hunan, P.R.China}
\add{2}{School of Computer and Communication Sciences, 
	École Polytechnique Fédérale de Lausanne (EPFL),
	 Lausanne, Switzerland}
\add{3}{Cyberhaven, Inc., 401 Park Drive, Suite 811 Boston, 
	MA 02215, USA}
\email{bizh4ng@hotmail.com}}

\begin{abstract}
Coverage-based fuzz testing and dynamic symbolic execution are both 
popular program testing techniques. However, on their own, both techniques 
suffer from scalability problems when considering the complexity of 
modern software. Hybrid testing methods attempt to mitigate these 
problems by leveraging dynamic symbolic execution to assist fuzz 
testing. Unfortunately, the efficiency of such methods are still 
limited by specific program structures and the schedule of seed files.

In this paper, we introduce a novel lazy symbolic pointer concretization 
method and a symbolic loop bucket optimization to mitigate path explosion 
caused by dynamic symbolic execution in hybrid testing.
We also propose a distance-based seed selection method to rearrange the 
fuzzer's seed queue in order to achieve higher coverage. We implemented 
a prototype and evaluate its ability to find vulnerabilities in software 
and cover new execution paths. We show on three different benchmarks (a 
demo program, the LAVA benchmark, and a set of real-world programs) that 
it can find more crashes than other off-the-shelf vulnerability 
detection tools. We also show that our method can discover 43\% more 
unique paths than vanilla fuzz testing.
\end{abstract}

\maketitle

\section{Introduction} \label{sec:introduction}
\input{Introduction.tex}


\section{Preliminaries} \label{sec:preliminaries}
\input{Preliminaries.tex}

\section{Mitigating Path Explosion in \textit{SPF}} \label{sec:ease PE}
\input{selective-assist.tex}

\section{Distance-based Seed Selection} \label{sec:seed selection}
\input{seed-priority.tex}

\section{Implementation and Evaluation} \label{sec:evaluate}
\input{Implementation.tex}

\input{Evaluation.tex}

\section{Limitations and Discussion} \label{sec:discussion}
\input{Discussion.tex}

\section{Related Work} \label{sec:related}
\input{RelatedWork.tex}

\section{Conclusion} \label{sec:conclusion}
In this paper, we focused on improving the performance of hybrid 
testing method built on coverage based fuzz testing and dynamic 
symbolic execution. We proposed a novel method, lazy concretization, 
to deal with symbolic pointers. We found that this method mitigates 
the path explosion problem and improves code coverage. We also introduced 
the loop bucket optimization in order to avoid generating too many 
states in symbolic loops. In order to deal with the large size of 
the seed queue in hybrid testing, we presented a distance-based seed 
selection method to achieve more coverage when testing time is limited. 
This criteria of selection method is built on top of runtime information 
(i.e, path and memory information). The evaluation of \prototype 
on several benchmarks demonstrates that our method can discover more 
unique paths than vanilla fuzz testing and finds more bugs compared 
with other off-the-shelf vulnerability analysis tools.

\bibliography{biblio.bib}
\bibliographystyle{plain}

\vfill\pagebreak

\end{document}
