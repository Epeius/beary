Software errors and vulnerabilities have brought critical threaten to not only individuals but also for the whole cyber security. Despite the software quality of software engineering has ever-increasing, some software vulnerabilities still can be found every year by researchers both in academia and industrial communities. 

Even though some software errors and vulnerabilities can be discovered manually, manual analysis is still not a scalable method for large-scale software. During the past several years, many automatic methods have been proposed to improve the dependability of software before and after the software have been released, like source code auditing, fuzz testing, symbolic execution. However, all of these methods still need to solve some obstacles before they can be well applied to large-scale real-world software.

Source code auditing is a powerful methodology for locating security vulnerabilities in source code. However, the need to access source code prevents it from being deployed onto binary software testing to detect vulnerabilities in the released binary executables. 
  
 needs to access source code which prevent it from being deployed onto binary software testing. And even though it can obtain more information from the source code than binary, it still cannot make sure there are no vulnerabilities in the released binary executables. Fuzz testing is used to automatically discover vulnerabilities in binary executables and it is the most popular technique in the industrial community and according to the [XXX], most of the vulnerabilities in CVE and NVD databases are discovered by fuzz testing. However, a large portion of released fuzzing tools treats the target software as a black box which means they simply feed the target binaries with randomly generated test cases. And obviously, only a very small portion of the randomly generated test cases can trigger new behaviors of the target binary by touching new paths or basic blocks. While most of the test cases are proved as redundant and there has no doubt that black box fuzz testing faces a serious efficiency problem.

Symbolic execution is an analysis method to automatically generate an input that can drive some specific code region to be executed. Symbolic execution interprets the target program by assigning symbolic data rather than concrete data to the program inputs and then uses SAT solvers to generate test cases that satisfy with both branches when encountering a branch. However, the "path explosion" problem impedes symbolic execution from applying to real-world software. During the recent years, some improvements have been made to help symbolic execution to be adaptable to real-world testing, like, selective symbolic execution and so on. Selective symbolic execution bounds the number of execution states though "elastic" expanding the program execution path. Selective symbolic execution has eased the ?path explosion? problem to some extent and made it possible for applying symbolic execution to real-world software. And based on such improvements, some automatic symbolic execution tools have been developed, such as EXE, KLEE, SAGE, Mayhem, S2E and Angr. 

We realized that even the state of the art effective technique base on program analysis is less efficient than black box fuzzing if the time spent generating a test case take relatively too long. Symbolic execution has to spend the most time on program analysis and constraint solving, while black box fuzzing only concentrate on random mutations. In this paper, we aim to improve the performance of fuzz testing by adding two main features for fuzz testing. We proposed a similarity based seed searcher for fuzz testing to speed up the path discovery, and we also leveraged symbolic execution to improve the coverage of fuzz testing by selectively solving the branches which are guarded by complex conditions. And we also present our prototype which is built on top of our method. Furthermore, some additional evaluations are performed to demonstrate the ability of our methods \cite{patashnik-bibtexing}.
 
In summary, this paper makes the following contributions.
\begin{itemize}
\item We proposed a novel method to prioritize the seed files for fuzz testing to speed up the path discovery.

\item We propose a novel method based on lazy forking to handle the \emph{symbolic pointers} when using symbolic execution to assist fuzz testing.

\item We designed and built the prototype for our method to demonstrate our approaches.

\item We evaluate our method and prototype on several benchmarks to demonstrate the effectiveness and efficiency from several different viewpoints.
\end{itemize}